#include <Arduino.h>
#include <Servo.h>

// Pines del sensor ultrasonico HC-SR04
#define TRIGGER_PIN 12
#define ECHO_PIN 13
#define SERVO_PIN 11

// Pines L298N
#define MOTOR_IZQ_IN1 8
#define MOTOR_IZQ_IN2 9
#define MOTOR_IZQ_ENA 5
#define MOTOR_DER_IN3 10
#define MOTOR_DER_IN4 7
#define MOTOR_DER_ENB 6

// Pines de encoders (sensores infrarrojos en las ruedas)
#define ENCODER_IZQ_PIN 2  // Interrupción 0
#define ENCODER_DER_PIN 3  // Interrupción 1

// Constantes
#define DISTANCIA_MINIMA 30
#define DISTANCIA_CRITICA 15
#define VELOCIDAD_MINIMA 100
#define VELOCIDAD_MAXIMA 200
#define VELOCIDAD_GIRO 140

// Encoders: ranuras por revolución de la rueda
#define RANURAS_POR_VUELTA 20  // Ajustar según tu disco encoder
#define DIAMETRO_RUEDA_CM 6.5  // Diámetro de la rueda en cm

// Variables de encoders (volatile porque se usan en interrupciones)
volatile long pulsosIzq = 0;
volatile long pulsosDer = 0;
volatile unsigned long tiempoUltimoPulsoIzq = 0;
volatile unsigned long tiempoUltimoPulsoDer = 0;

// Variables de control PID
float velocidadObjetivoIzq = 0;
float velocidadObjetivoDer = 0;
int pwmIzq = 0;
int pwmDer = 0;

Servo servoSensor;
long distancia = 0;
int velocidadActual = VELOCIDAD_MINIMA;

// Funciones de interrupción para encoders
void IRAM_ATTR pulsoEncoderIzq() {
  pulsosIzq++;
  tiempoUltimoPulsoIzq = millis();
}

void IRAM_ATTR pulsoEncoderDer() {
  pulsosDer++;
  tiempoUltimoPulsoDer = millis();
}

// Calcular velocidad real de cada rueda (cm/s)
float calcularVelocidadIzq() {
  unsigned long tiempoTranscurrido = millis() - tiempoUltimoPulsoIzq;
  if (tiempoTranscurrido > 500) return 0; // Rueda detenida
  
  float circunferencia = PI * DIAMETRO_RUEDA_CM;
  float distanciaPorPulso = circunferencia / RANURAS_POR_VUELTA;
  
  // Calcular velocidad basada en tiempo entre pulsos
  return distanciaPorPulso / (tiempoTranscurrido / 1000.0);
}

float calcularVelocidadDer() {
  unsigned long tiempoTranscurrido = millis() - tiempoUltimoPulsoDer;
  if (tiempoTranscurrido > 500) return 0;
  
  float circunferencia = PI * DIAMETRO_RUEDA_CM;
  float distanciaPorPulso = circunferencia / RANURAS_POR_VUELTA;
  
  return distanciaPorPulso / (tiempoTranscurrido / 1000.0);
}

// Control PID simplificado para igualar velocidades
void ajustarVelocidadesConPID() {
  float velIzq = calcularVelocidadIzq();
  float velDer = calcularVelocidadDer();
  
  // Corrección proporcional simple
  float diferencia = velIzq - velDer;
  int correccion = diferencia * 5; // Factor de corrección
  
  // Ajustar PWM de cada motor
  pwmIzq = velocidadActual - correccion;
  pwmDer = velocidadActual + correccion;
  
  // Limitar valores
  pwmIzq = constrain(pwmIzq, 0, 255);
  pwmDer = constrain(pwmDer, 0, 255);
  
  // Aplicar PWM corregido
  analogWrite(MOTOR_IZQ_ENA, pwmIzq);
  analogWrite(MOTOR_DER_ENB, pwmDer);
  
  // Debug
  Serial.print("VelIzq: ");
  Serial.print(velIzq);
  Serial.print(" cm/s | VelDer: ");
  Serial.print(velDer);
  Serial.print(" cm/s | PWM I:");
  Serial.print(pwmIzq);
  Serial.print(" D:");
  Serial.println(pwmDer);
}

// Calcular distancia recorrida
float distanciaRecorridaIzq() {
  float circunferencia = PI * DIAMETRO_RUEDA_CM;
  return (pulsosIzq * circunferencia) / RANURAS_POR_VUELTA;
}

float distanciaRecorridaDer() {
  float circunferencia = PI * DIAMETRO_RUEDA_CM;
  return (pulsosDer * circunferencia) / RANURAS_POR_VUELTA;
}

// Resetear contadores de encoder
void resetearEncoders() {
  pulsosIzq = 0;
  pulsosDer = 0;
}

// Funciones de movimiento mejoradas
void avanzarConEncoders(int velocidad, float distanciaCm = 0) {
  digitalWrite(MOTOR_IZQ_IN1, HIGH);
  digitalWrite(MOTOR_IZQ_IN2, LOW);
  digitalWrite(MOTOR_DER_IN3, HIGH);
  digitalWrite(MOTOR_DER_IN4, LOW);
  
  velocidadActual = velocidad;
  resetearEncoders();
  
  if (distanciaCm > 0) {
    // Avanzar una distancia específica
    while (distanciaRecorridaIzq() < distanciaCm && distanciaRecorridaDer() < distanciaCm) {
      ajustarVelocidadesConPID();
      delay(10);
    }
    detener();
  } else {
    // Avanzar continuo con corrección
    ajustarVelocidadesConPID();
  }
}

void girarGrados(int grados, bool derecha) {
  // Calcular distancia que debe recorrer cada rueda para el giro
  float distanciaBase = 15; // cm entre ruedas
  float arcoGiro = (PI * distanciaBase * grados) / 360.0;
  
  resetearEncoders();
  
  if (derecha) {
    digitalWrite(MOTOR_IZQ_IN1, HIGH);
    digitalWrite(MOTOR_IZQ_IN2, LOW);
    digitalWrite(MOTOR_DER_IN3, LOW);
    digitalWrite(MOTOR_DER_IN4, HIGH);
  } else {
    digitalWrite(MOTOR_IZQ_IN1, LOW);
    digitalWrite(MOTOR_IZQ_IN2, HIGH);
    digitalWrite(MOTOR_DER_IN3, HIGH);
    digitalWrite(MOTOR_DER_IN4, LOW);
  }
  
  analogWrite(MOTOR_IZQ_ENA, VELOCIDAD_GIRO);
  analogWrite(MOTOR_DER_ENB, VELOCIDAD_GIRO);
  
  while (distanciaRecorridaIzq() < arcoGiro || distanciaRecorridaDer() < arcoGiro) {
    delay(10);
  }
  
  detener();
}

void detener() {
  digitalWrite(MOTOR_IZQ_IN1, LOW);
  digitalWrite(MOTOR_IZQ_IN2, LOW);
  analogWrite(MOTOR_IZQ_ENA, 0);
  digitalWrite(MOTOR_DER_IN3, LOW);
  digitalWrite(MOTOR_DER_IN4, LOW);
  analogWrite(MOTOR_DER_ENB, 0);
}

long medirDistancia() {
  digitalWrite(TRIGGER_PIN, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIGGER_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIGGER_PIN, LOW);
  
  long duracion = pulseIn(ECHO_PIN, HIGH, 30000);
  long dist = duracion * 0.034 / 2;
  
  if (dist == 0 || dist > 400) dist = 400;
  return dist;
}

void setup() {
  Serial.begin(9600);
  
  pinMode(TRIGGER_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);
  
  pinMode(MOTOR_IZQ_IN1, OUTPUT);
  pinMode(MOTOR_IZQ_IN2, OUTPUT);
  pinMode(MOTOR_IZQ_ENA, OUTPUT);
  pinMode(MOTOR_DER_IN3, OUTPUT);
  pinMode(MOTOR_DER_IN4, OUTPUT);
  pinMode(MOTOR_DER_ENB, OUTPUT);
  
  // Configurar encoders con interrupciones
  pinMode(ENCODER_IZQ_PIN, INPUT_PULLUP);
  pinMode(ENCODER_DER_PIN, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(ENCODER_IZQ_PIN), pulsoEncoderIzq, RISING);
  attachInterrupt(digitalPinToInterrupt(ENCODER_DER_PIN), pulsoEncoderDer, RISING);
  
  servoSensor.attach(SERVO_PIN);
  servoSensor.write(90);
  
  delay(1000);
  Serial.println("Robot con encoders iniciado");
}

void loop() {
  servoSensor.write(90);
  delay(100);
  
  distancia = medirDistancia();
  Serial.print("Dist: ");
  Serial.print(distancia);
  Serial.println(" cm");
  
  if (distancia > DISTANCIA_MINIMA) {
    // Avanzar con control de velocidad balanceado
    avanzarConEncoders(VELOCIDAD_MAXIMA);
    delay(50);
    
  } else if (distancia > DISTANCIA_CRITICA) {
    avanzarConEncoders(VELOCIDAD_MINIMA);
    delay(100);
    
  } else {
    Serial.println("Obstáculo detectado");
    detener();
    delay(200);
    
    // Retroceder 10 cm exactos
    Serial.println("Retrocediendo 10 cm");
    digitalWrite(MOTOR_IZQ_IN1, LOW);
    digitalWrite(MOTOR_IZQ_IN2, HIGH);
    digitalWrite(MOTOR_DER_IN3, LOW);
    digitalWrite(MOTOR_DER_IN4, HIGH);
    resetearEncoders();
    
    while (distanciaRecorridaIzq() < 10) {
      analogWrite(MOTOR_IZQ_ENA, VELOCIDAD_MAXIMA);
      analogWrite(MOTOR_DER_ENB, VELOCIDAD_MAXIMA);
      delay(10);
    }
    detener();
    delay(200);
    
    // Girar 90 grados (ajustar según necesidad)
    Serial.println("Girando 90°");
    girarGrados(90, true);
    delay(300);
  }
}
